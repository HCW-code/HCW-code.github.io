---
layout: single
title: "[블록체인] 니모닉"
categories: blockchain
tag: [mnemonic,니모닉]
toc: true

---

## 니모닉(Mnemonic)

니모닉이란 결정적 지갑에서 난수를 12개의 영단어로 인코딩한 영단어 그룹으로 BIP39에서 제안되었다.

기존의 시드 키는 숫자와 문자로 구성된 난수이기 때문에 사용자가 기억하기 어려웠지만 니모닉 코드 단어의 경우 사용자가 기억하고 사용하기 쉬운 형태로 구성되어 있다는 장점이 있다.
<center>
<img src="../../images/2022-08-30-blockchain_12th/image-20220830134851379.png" alt="image-20220830134851379" style="zoom:50%;" />
</center>
블록체인에서 니모닉은 지갑을 복구하기 위한 일반적인 단어들의 조합을 뜻한다.

숫자의 나열처럼 직관적인 관계가 없어 외우기 어려운 정보에 다른 정보를 연결하여 외우기 쉽도록 하는 데 쓰인다.

### 니모닉 Wallet

니모닉 Wallet은 니모닉을 사용하여 비밀키 관리를 용이하게 해주는 지갑이다.  
유저는 비밀 키를 잃어버릴 수 있다는 위험성 때문에 비밀키를 복구(리커버리)할 때 니모닉을 사용하게 된다.

니모닉 Wallet은 암호화폐 지갑의 핵심인 비밀키 관리를 용이하게 해주고, 모든 비밀 키를 니모닉으로 관리하는 지갑이다.  
사실 암호화폐 지갑에 화폐 자체가 들어있는것은 아니며 암호화폐 지갑은 키를 관리하는 키 매니지먼트 시스템이라고 할 수 있다.  
예를 들어, 내 계정에 있는 이더리움을 내 것이라고 증명할 수 있는 비밀 키를 지갑이 관리한다고 보면 된다.

### 니모닉이 필요한 이유

디지털 서명을 분산 장부에서 쉽게 표현하면 다른 이가 보지 못하고, 내 행위를 증명하는 것으로 사용된다.  
이 디지털 서명에 사용되는 방식 중 비대칭 키 암호 방식에는 공개 키(Public key)와 비밀 키(Private key)가 있다.  
비밀 키로는 공개 키가 계산이 되는데 공개 키로는 비밀 키가 이론적으로 계산이 가능하지만 현실적으로 불가능하다. 그래서 비밀 키만 갖고있으면 공개 키는 여기저기 공개해도 상관이 없다. 그래서 공개 키는 주로 계좌번호 처럼 쓰이게 된다.

암호화폐 지갑은 비대칭 키 암호 방식을 사용한다. 그래서 공개 키와 비밀 키가 사용이 되는데, 이 비밀 키를 사람이 쓰기 편하게 만들어진 것이 바로 니모닉(mnemonic)이다.

비밀 키의 암호화 알고리즘 보안 성능은 2^256(2의 256승)이다. 이것을 사람이 사용하기엔 엄청나게 큰 수이기 때문에 16진수 64글자로 바꾼다. 여기에 비슷하게 생긴 글자들(ex. 0, O)을 제외한 58개를 갖고 2^256을 표현하더라도 사람이 쓰기엔 불편하다.

니모닉은 순서대로 맞춰진 단어가 암호화된 보안 비밀번호 방식으로, 문자 배열을 초기대로 하지 못하면 어느 누구도 지갑을 열 수 없다.

니모닉은 12개 또는 24개의 랜덤한 영어 단어로 이루어져 있다. 일반적인 단어로 표현되는 니모닉 코드는 암호화폐 지갑 사용자가 난해한 기술에 대한 이해 없이도 지갑을 편리하게 사용할 수 있도록 돕는다.

### 니모닉 코드와 시드 생성 9단계

니모닉 코드는 해시 함수를 재귀적으로 반복하는 키 스트레칭 과정을 거쳐 마스터 시드를 생성하고, 그 마스터 시드는 HD 지갑 주소 생성의 바탕이 된다.

BIP-39에 정의된 니모닉 코드와 시드 생성 9단계는 다음과 같다.
<center>
<img src="../../images/2022-08-30-blockchain_12th/image-20220830135928574.png" alt="image-20220830135928574" style="zoom:50%;" />
</center>
1. 128bit 또는 256bit 길이의 난수를 생성한다.
2. 난수를 SHA-256 알고리즘으로 해싱하고, 해시값에서 (시드키의 길이)/32 만큼을 떼어낸다. 가령, 난수의 길이가 128bit라면, 해시값에서 128/32인 4bit를 앞에서부터 떼어내 체크섬으로 만든다.
3. 체크섬을 난수의 뒤에 붙인다.
4. 체크섬을 붙인 난수를 11bit 단위로 잘라낸다.
5. 각 11bit의 단어를 사전에 정의된 단어로 치환한다.
6. 각 11bit의 순서를 유지하여 일련의 니모닉 코드를 만든다.

위의 과정을 통해 128~256bit 길이의 엔트로피를 표현하는 니모닉 코드가 생성되었다.

이제 이 엔트로피와 키 스트레칭 함수 PBKDF2를 사용하여 더 긴(512bit) 시드를 파생시킨다.

키 스트레칭 함수에는 니모닉 코드와 솔트(salt)라는 두가지 파라미터를 넣는다.
<center>
<img src="../../images/2022-08-30-blockchain_12th/image-20220830140322797.png" alt="image-20220830140322797" style="zoom:50%;" />
</center>
7. PBKDF2 키 스트레칭 함수의 첫 번째 인자는 6단계에서 생성 된 니모닉 코드이다.
8. PBKDF2 키 스트레칭 함수의 두 번째 인자는 솔트이다. 솔트는 문자열 상수 "mnemonic"과 선택적으로 사용자가 지정한 암호문을 연결하여 구성한다.
9. PBKDF2는 최종 출력으로 512비트 값을 만드는 HMAC-SHA512알고리즘으로 2048 해시 라운드를 사용하여 니모닉과 솔트 파라미터를 확장하며, 이 결과로 나온 512비트 값이 seed이다.

### 추가

솔팅은 원본 데이터에 임의의 문자열인 솔트(Salt)를 추가하여 해싱하는 방식이다. 솔팅 방식으로 비밀번호를 암호화하여 데이터베이스에 보관하면, 해커가 솔트가 무엇인지 알지 못하는 이상 레인보우 테이블의 해시값과 데이터베이스의 해시값을 비교해도 원본 비밀번호를 알 수 없다.
<center>
<img src="../../images/2022-08-30-blockchain_12th/image-20220830140715051.png" alt="image-20220830140715051" style="zoom:50%;" />
</center>
키 스트레칭은 이러한 솔팅 방식을 여러번 반복하는 것이다. 솔팅의 결괏값을 다시 솔트 함수의 입력값으로 하여 다시 솔팅을 하고, 이 과정을 반복한다.

사용자가 입력한 비밀번호는 예측하기 쉬운 경우가 많은데, 키 스트레칭은 이러한 예측을 더욱 어렵게 해준다.
<center>
<img src="../../images/2022-08-30-blockchain_12th/image-20220830140850860.png" alt="image-20220830140850860" style="zoom:50%;" />
</center>