---
layout: single
title: "[algorithm] B-tree"
categories: algorithm
tag: [algorithm, b-tree]
toc: true


---

## B-tree

### 개념

B-트리는 데이터를 효율적으로 저장하고 탐색하기 위한 자료 구조입니다. 데이터베이스 및 파일 시스템에서 널리 사용되며, 데이터를 순서대로 저장하고 빠르게 검색하는데 사용됩니다.

대용량 데이터는 메모리가 아닌 주로 외장하드에 저장되며 디스크는 고정 크기 블록으로 배열된다. 그래서 탐색을 할때 노드가 저장된 블록이 메모리로 로드되는 형태이다. 그래서 블록안에 데이터의 양이 어떻든 고정된 크기를 가져오게 되어있으므로 이진트리형태가 아닌 여러 데이터를 담을 수 있는 트리형태로 발전시켜 효율적으로 저장하고 탐색할 수 있게 만든 트리 형태의 자료 구조입니다.



### B-tree 시간복잡도 logN의 증명

16 8 4 2 1 => k번째에 1이 된다 생각하면

2^k = N

K = logN 이 된다.

자식노드의 개수로 쪼개지기 때문에 이를 활용하여 log3 N 될수 도 있다.

평균적으로 logN의 시간 복잡도를 갖게 만들어준다.



### 특징

- 모든 리프노드가 같은 레벨

- 여러 개의 자식을 가질수 있다. N(데이터 개수)+1개 만큼의 자식노드를 가진다.

- 루트와 잎들을 제외한 모든 노드는 적어도 *m*/2 개의 자식들을 가진다.

- 모든 노드가 가질 수 있는 키-링크 쌍 k의 수는 *M/*2≤*k*≤*M*−1 개이다.

- 블록 단위 접근

- - btree는 데이터를 블록단위로 저장하고 접근하며 블록은 보통 디스크 또는 메모리의 고정된 크기를 가진다. 그래서 한번에 하나의 블록을 읽거나 쓸 수 있고 이를 통해 입출력 비용을 최소화하고 효율적인 데이터 접근이 가능하게 한다.

- 삽입, 삭제시에 동적으로 트리 구조를 조정한다.





### 탐색

- 루트노드에서 부터 시작해서 블록을 메모리에 로드 시켜서 데이터를 탐색한다.
- 해당 데이터가 노드에 없으면 기준에 맞는 포인터를 이용하여 다음 블록을 메모리에 로드하여 다시 찾습니다.

### 삽입

- 리프노드에 추가한다.
- 오버 플로우 발생 시 중간값을 부모로 올려서 오버플로우 발생한 노드를 반으로 나눠 리프에 저장
- 만약 부모노드가 오버플로우 시 반복작업하며 올라간다.

### 삭제









### 성능

**명제**
N개의 항목을 가진 오더 M인 B-트리에서의 탐색 또는 삽입 작업은 logM N 에서 logM/2 N회에 이르는 탐지를 소요한다. 이 값은 실제 응용에서 상수에 가깝다.

**증명**
M개의 키로 가득 찬 노드를 나누면서 트리가 커 나가기(자식이 분할되면서) 때문에 트리 내부에 있는 모든 노드(뿌리 노드와 외부 노드가 아닌 노드)가 M/2에서 M− 범위의 링크를 가진다. 위 명제는 이 부분에서 유도된다. 최적 조건에서 이 노드들은 가지 브랜치 비율이 M−1인 완전 트리가 된다. 이 경우 기술된 경계 값이 직접적으로 유도된다. 최악 조건에서는 각각 차수 M2인 완전 트리를 가리키는 항목 두 개가 뿌리 노드에 있게 된다. 밑이 M인 로그를 취하면 매우 작은 숫자가 얻어진다. 예를 들어 M이 1,000 이라면 625억 개보다 작은 N에서 트리의 높이가 4보다 작다.

( log1000625×109=3.598...log1000⁡625×109=3.598... )