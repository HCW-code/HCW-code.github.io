---
layout: single
title: "[블록체인] 트릴레마를 고려해야 하는 이유"
categories: blockchain
tag: [blockchain, trilemma]
toc: true
---

### Safety와 Liveness

합의 프로토콜

- Safety

  : 시스템에 나쁜 일이 발생하지 않는다는 의미이며, 모든 정상적인 참여자는 같은 상태에 동의하여야 하고, 그 상태는 유효해야 한다. 다시 말해, 문제없는 노드는 잘못된 합의를 하지 않는다는 의미이다.

- Liveness

  시스템은 항상 살아있어야 한다는 의미이며, 결국에는 어떤 상태에 동의하여야 하고, 모든 참여자는 동의한 상태에 도달해야 한다. 다시 말해, 문제없는 노드는 반드시 합의한다는 의미이다.

#### FLP Impossibility

Safety는 문제 없는 노드 사이에서는 잘못된 합의가 이루어지지 않는다는 것이고, Liveness는 문제 없는 노드들은 반드시 합의한다는 것이다. 문제는 Byzantine Failure가 아닌 Fail-Stop Faliure(노드가 멈춘 것)가 하나만 있어도 Safety와 Liveness를 둘 다 만족하는 합의 알고리즘이 존재할 수 없다. 이를 FLP Impossibility 혹은 FLP Theorem이라고 한다. 이를 FLP Impossibility 혹은 FLP Theorem이라고한다.  
따라서 합의 알고리즘을 선택한다는 것은 사실상 Safety와 Liveness 중 무엇을 선택하고 포기할지의 문제이다.

#### Liveness over Safety

비트코인이 사용하는 합의 알고리즘은 Nakamoto Consensus라고도 불린다. Nakamoto Consensus는 언제나 더 어려운 문제를 푼 체인이 있으면 그 체인을 유효한 체인으로 판단한다. 즉, 지금 있는 체인보다 더 긴 체인을 만들 해시 파워만 있으면, 언제든지 현재 합의된 블록을 다른 블록으로 대체할 수 있다. 이런 방식을 블록체인에서는 Finality(완결성)가 보장되지 않는다고 말하고, FLP Impossibility에서는 Liveness를 위해서 Safety를 포기했다고 말한다.

Liveness를 중시하는 Nakamoto Consensus에서 출발한 합의 알고리즘들은 한정적인 상황에서 Safety를 보장할 방법을 추가하는 방식으로 발전하였다. 이더리움에서 구현되고 있는 Casper, the Friendly Finality Gadget이 대표적입니다. Casper는 기존의 PoW로 Liveness를 보장하며 블록을 생성하지만, 50블록마다 투표하여 Safety가 보장되는 지점을 만든다.

#### Safety over Liveness

전통적으로 분산 시스템에서 연구되던 PBFTY에 기반한 BFT 계열 합의 알고리즘들은 Safety를 중시하는 합의 알고리즘에 속한다. Cosmos에서 사용하는 Tendermint가 대표적인 Safety를 보장하는 BFT알고리즘이다.

Tendermint는 하나의 라운드가 Propose, Prevote, Precommit 3개의 단계로 나누어진다. 이 중 Prevote와 Precommit 스템에서 각각 2/3 + 1개 이상 모아야 합의가 이루어진다. 합의에 2/3 + 1개 이상의 동의가 필요하기 때문에 어떤 상황에서도 서로 다른 두 블록이 동시에 생성되는 일은 없다. 하지만 전송한 메시지가 시간 안에 도달하는 것을 보장하지 못하는 비동기 네트워크에서는 합의가 이루어지지 않아 블록이 생성되지 않을 수 있다. 따라서 Liveness가 보장되지 않는다.

FLP Impossibility가 증명했듯이 Safety가 보장되는 경우 어떤 방법을 사용해도 비동기 네트워크에서 Liveness를 보장할 수 없다. 그래서 BFT 계열에서는 다른 네트워크 모델에서 Liveness가 보장됨을 증명한다.

비동기 네트워크 모델에서는 메시지가 전송되는 것이 보장되는 시간이 없다. 그렇다고 해서 정해진 시간 안에 메시지 전달이 보장되는 동기 네트워크 모델을 사용할 수는 없다. 이는 인터넷 규모의 네트워크에서는 비현실적인 가정이고, 이런 가정에서 Liveness를 증명하는 것은 아무 의미 없기 때문이다. 그래서 Tendermint는 정해진 시간 안에 메시지가 도달하는 것이 보장되지만 그 정해진 시간을 알 수 없다는 Partial Synchronous Network Model을 사용한다.

Partial Synchronous Network는 정해진 시간 내에 메시지가 도착하는 것이 보장되는 모델이다. 다만 이 정해진 시간이 무엇인지 노드는 알지 못하며, 이는 꽤 현실적인 모델이다. 현실의 네트워크도 Omission Failure가 발생하지 않는 한 언젠가는 메시지가 도착하기 때문이다.

BFT계열의 합의 알고리즘은 블록 생성을 위해 2번의 투표를 모아야한다. 비록 Partial Syncronous Network Model에서는 언젠가 합의될 것이 보장되지만, 최악의 경우 몇 번의 라운드 동안 새 블록이 생성되지 않아서 TPS 저하를 초래하는 경우도 생긴다.

BFT 계열 알고리즘은 이런 문제를 해결하기 위한 방향으로 발전했다. 2018년 3월에 발표된 Hot-Stuff이라는 프로토콜이 대표적이다. Hot-Stuff에서 블록은 Validator들의 투표를 포함한다. 이 투표를 Commit-Certificate(a.k.a CC)이라고 한다. Hot-Stuff은 기존의 BFT 계열의 알고리즘과 다르게 CC가 없는 블록도 생성될 수 있다. 그저 이 블록들은 Finality가 보장되지 않을 뿐이다. 이 CC가 없는 블록들은 뒤에 CC가 있는 블록의 Finality가 보장되면 그때 Finality가 보장된다. 바로 시간당 블록 생성량을 올리기 위해서 Safety를 어느 정도 포기하는 것이다.

### BFT:비잔틴 장군 문제

분산 네트워크 환경에서 악의적인 노드가 존재할 때 이를 어떻게 극복하고 합의에 도달할 수 있느냐가 "비잔틴 장군의 딜레마"이다.
<center>
<img src="../../images/2022-09-02-blockchain_15th/image-20220902143832164.png" alt="image-20220902143832164" style="zoom:50%;" />
</center>
위 방법이 성공하기 위해서는 중요한 가정이 필요하다.

- 배신자의 수보다 신뢰자의 수가 많아야 한다.
- 2/3 다수결이 충족되어야 한다.

이를 수식화해보면, 악의적인 노드 N개 있을 때, 총 노드가 3N+1이어야 하고 N을 제외하고는 모두 신뢰할 수 있는 노드여야 한다가 된다.

즉, 3N+1의 노두 개수가 있다면 N개의 악의적인 노드가 있더라도 2/3 다수결에 의해 합의를 끌어낼 수 있게 되는 것이다.

이러한 방식의 합의 알고리즘을 PBFT(Practical Byzantine Fault Tolerance), 프랙티컬 비잔틴 허용이라고 한다.

하지만 이 방식은 소규모 노드라면 크게 문제가 없겠지만, 노드가 늘어날수록 통신량은 기하급수적으로 늘어나게 되어서 비용이 너무 크다는 것이 단점이다. 따라서 PBFT 방식은 Public 블록체인에는 적합한 방식이 아니다.

### CFT(Crash Fault Tolerance) vs. BFT(Byzantine Fault Tolerance)

CFT는 분산 시스템에서 노드가 비정상적인 충돌에 의해 문제가 생기더라도, 나머지 시스템에서 서비스를 할 수 있게 하는 작동방식을 말한다. 반면 BFT는 더 복잡하며 악의적인 행위자가 있을 수 있는 시스템을 처리한다.

블록체인 시스템에선 둘 다 합의라는 방식을 거치게 되는데, 비트코인의 경우는 일반적인 CFT, BFT보다 높은 수준의 신뢰 작업을 필요로 한다. 이것이 바로 PoW(작업증명)이다.

컨소시엄형 블록체인 시스템(하이퍼레저 패브릭 등)에서는 보통 조직들이 이미 신원확인 등을 통해 허가받은 상태에서 참여하기 때문에, 악의적인 행위를 하지 않을 것이라 믿고 서비스한다.  
따라서, 특정 상황에 노드에 문제가 생기는 경우에 대해서만 염두에 둔 CFT 기반의 오더링 알고리즘이 우선되고 있다.

### BFT(Byzantine Fault Tolerance)
<center>
<img src="../../images/2022-09-02-blockchain_15th/image-20220902155221756.png" alt="image-20220902155221756" style="zoom:50%;" />
</center>
인공위성과 비행기에서 쓰기 위한 장애 없는 분산 컴퓨터 시스템을 연구하던 Lamport, Shostak, Pease 3인이 1982년 공저한 논문에서, 중앙 통제장치가 없는 분산 컴퓨터 시스템은 일부 노드의 장애와 해킹 공격이 있으면 시스템을 안정적으로 운영하기 어렵다는 원리를 설명한다. 이때, 비잔티움 장군 문제를 처음으로 언급한다.

이 논문에서 몇가지 해결책을 제시하지만, 실제로 시스템을 실제로 구현한 것은 2009년 사토시 나카모토의 비트코인이 처음이다.

'Byzantine Fault Tolerance'라는 용어를 '비잔티움 장애 허용'이라고 주로 번역되는데, 번역에 따라 'Tolerance'를 '내성'이라고 번역하는 경우도 있다. 이는 비잔티움 장군 중 배신자를 '허용한다'가 아니라 '배신자가 있어도 견딘다'라는 의미를 나타내기도 한다.

#### 처리 절차
<center>
<img src="../../images/2022-09-02-blockchain_15th/image-20220902155541865.png" alt="image-20220902155541865" style="zoom:50%;" />
</center>
우선 클라이언트가 모든 노드에 요청을 브로드캐스트 한다. 리더가 처음 순차적으로 명령을 다른 노드에 전달한다. 각 노드는 브로드 캐스트된 명령을 받게 되면 리더를 포함한 모든 노드에 회신한다. 각 노드는 전달된 명령을 일정 수 이상(2n)이 수신하면 리더를 포함한 모든 노드에 수신한 내용을 재전송한다. 각 노드는 수신된 명령을 일정 수 이상(2n) 수신하면 명령을 실행하고 블록을 등록해 Client에 Replay된 메시지를 반환한다.

PoW나 PoS와는 달리 다수결로 의사 결정한 뒤 블록을 만들기 때문에 블록체인의 분기가 발생하지 않는다. 따라서 한 번 확정된 블록은 변경되지 않기 때문에 완결성을 확보할 수 있다. 또한 PoW와 같이 조건을 만족시킬 때까지 계산을 반복하지 않아도 되기 때문에 매우 고속으로 동작한다.

부정 사용을 하고자 해도 과반수를 얻어야 하며 만약 리더가 거짓말을 하더라도 모든 참가자가 리더의 움직임을 감시해 거짓말이라고 판단한다면 다수결로 리더 교체를 신청할 수 있기 때문에 장애에 매우 강력한 내성을 지닌 알고리즘이다.

반면 언제나 참가자 전원과 의사소통해야하므로 참가자가 증가하면 통신량이 증가하고 처리량이 저하된다. 따라서 PoW나 PoS는 수천 개의 노드를 만들 수 있지만 BFT는 수십 개의 노드가 한계이다.

### PBFT(Practical Byzantine Fault Tolerance)

PBFT는 분산 시스템이 약속된 행동을 하지 않는 비잔틴 노드가 존재할 수 있는 비동기 시스템일 때 해당 분산 시스템에 참여한 모든 노드가 성공적으로 합의를 이룰 수 있도록 개발된 합의 알고리즘이다. PBFT는 기존의 BFT 합의 알고리즘이 동기식 네트워크에서만 합의할 수 있었던 문제를 해결하여 비잔틴 노드가 있는 비동기 네트워크에서 합의를 이룰 수 있게 하였다.
<center>
<img src="../../images/2022-09-02-blockchain_15th/image-20220902162157807.png" alt="image-20220902162157807" style="zoom:50%;" />
</center>
위의 그림은 PBFT 알고리즘이 동작하는 방식을 나타낸 것이다. 이러한 기존 분산 시스템에서 사용하던 합의 알고리즘은 Primary 혹은 Leader라 불르는 특별한 노드가 존재한다. 이 노드는 클라이언트의 요청 순서를 정렬하고 요청에 대한 결과를 기재하여 최초로 다른 노드들에게 전달하는 역할을 한다.

리더가 클라이언트의 요청을 수집하여 정렬하고 실행 결과와 함께 다른 노드들에 전파한다. 리더의 메시지를 받은 노드들은 다른 노드들에서 받은 메시지를 다시 한번 나머지 노드들에게 전파한다. 모든 노드는 자신이 다른 노드에서 가장 많이 받은 같은 메시지(정족수 이상의)가 무엇인지 다른 노드들에게 전파한다. 모든 과정이 끝나면 모든 노드는 정족수 이상이 동의한, 즉 합의를 이룬 같은 데이터를 가지게 된다.

PBFT는 두번의 브로드캐스트 과정을 이용해 비잔틴 리더나 비잔틴 검증 노드가 네트워크 분기를 위해 이상한, 혹은 임의의 메시지를 보내도 네트워크의 모든 노드는 같은 메시지를 가질 수 있게 하였다. 이러한 PBFT 알고리즘은 IBM fabric 0.6v이나 1.0v의 Orderer서비스, R3 Corda의 Notary와 같은 프라이빗 블록체인에서 사용하고 있다.

#### PBFT의 장점

1. 트랜잭션 완결성과 빠른 거래 확정 : PBFT는 다음 블록 합의가 이루어진다면 제안된 블록의 합의 내용이 확정되어서 한번 확인으로 거래가 완결되므로 거래 확정 시간이 짧다.
2. 저에너지로 비용 감소 : PBFT는 작업 증명방식이 아니고 지분증명방식을 기본으로 하여 에너지 사용량이 적고, 따라서 거래 비용이 적다.

### Tendermint
<center>
<img src="../../images/2022-09-02-blockchain_15th/image-20220902162748146.png" alt="image-20220902162748146" style="zoom:50%;" />
</center>
Tendermint는 Cosmos에서 사용하는 합의 알고리즘으로 PBFT 알고리즘을 공개 및 비공개 블록체인에 맞도록 개량한 합의 알고리즘이다. Tendermint는 전통적인 합의 알고리즘이 블록체인에 적용된 의미 있는 사례이며 DPoS 개념과 PBFT 개념을 섞어 공개 및 비공개 블록체인에서 사용할 수 있도록 한 합의 알고리즘이다.

Tendermint 프로세스에서의 Propose는 PBFT의 Pre-Prepare, Prevote는 Prepare, Precommit은 PBFT의 Commit으로 매칭시키면 이해가 쉽다.

Tendermint는 앞에서 언급하였듯이 PBFT에 DPoS개념을 추가하여 블록체인에 적합한 합의 알고리즘을 개발하였다. 차이점을 요약하면 기존의 PBFT는 하나의 노드가 하나의 투표를 하는 방식으로 투표를 받아 가장 많은 투표를 받은 블록을 승인하지만, Tendermint는 지분(Stake)을 기반으로 투표하게 된다. 이때 투표하는 노드의 수보다는 지분이 중요하다.

Tendermint는 투표할 때 Locking 메커니즘을 통해 투표에 참여한 지분을 네트워크에 동결시키고 이를 해제하는 메커니즘을 통해 이중 투표 문제를 막고 지분으로 네트워크를 유지하게 한다. 또한 이중 투표 시도와 같은 블록체인을 공격하려는 악의적인 행위를 하면 지분을 빼앗는 방법으로 기존의 블록체인이 네트워크 공격 노드에 아무런 처벌을 하지 않던 문제를 해결하였다.

#### Tendermint의 장점

1. 블록을 노드들에게 전파(Gossip)하는 방식을 단순화하고 노드의 수를 늘릴 수 있게 했다.
2. 블록제안자를 수시로 교체할 수 있게 하여 안전성을 높였다.
3. 비잔티움 노드를 쉽게 발견하여 처벌 할 수 있도록 했다.

### PBFT의 한계

PBFT는 합의 그룹 크기가 커짐에 따라 합의 속도가 느려지는 문제가 있다. 100개 이상의 노드를 운영하기 쉽지 않으며 예를 들어 Cosmos는 100개 노드로  운영하면 거래 확정에 약 6초 걸린다. 합의 그룹의 각 노드는 모든 다른 노드들과 두 번씩 메시지를 주고 받아야 하므로 전체 노드 N의 제곱 수준의 커뮤니케이션 교환이 필요하게 된다.

Number of communnications = N-1 + (N-1) * (N-1) + 2/3 (N-1) * (N-1) = N-1 + 5/4  (N-1)^2

100개의 노드로 합의를 이루려면 16434번의 통신이 필요하고, 49개 노드로 합의를 이루려면 3888번의 통신이 필요하다.

### DBFT(Delegated Byzantine Fault Tolerant)
<center>
<img src="../../images/2022-09-02-blockchain_15th/image-20220902164754383.png" alt="image-20220902164754383" style="zoom: 33%;" />
</center>
장점 : 빠른 처리 속도, 포크가 일어나지 않고 완료성이 좋다.

단점 : 특정 노드에 권력 집중, 노드들 간의 단합 위험