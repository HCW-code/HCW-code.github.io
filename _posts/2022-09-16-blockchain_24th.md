---
layout: single
title: "[블록체인] 스마트 컨트랙트 기초"
categories: blockchain
tag: [스마트 컨트랙트, 비트코인, 이더리움, utxo, evm, solidity]
toc: true

---

## 스마트 컨트랙트

스마트 컨트랙트는 블록체인 네트워크에 호스팅되고 실행되는 프로그램이다.  
조건을 지정해두고 해당 조건이 충족되면 미리 정해둔 계약을 이행하는 방식으로 코드를 작성한다.

스마트 컨트랙트는 일반적인 중앙 집중식 서버가 아니라 탈중앙화된 블록체인에서 실행하기 때문에, 계약 조건이나 이행 내용을 변조하기 어려우며 계약을 신뢰하기 위한 제삼자가 필요하지 않다.

### 특성과 특징

스마트 컨트랙트는 중개인의 존재 여부와 상과넚이, 조건이 충족된다면 계약이 이행되고, 조건이 충족되지 않는다면 이행되지 않는다는 특징을 가지고 있다. 이러한 스마트 컨트랙트의 특성은 블록체인이 가지고 있는 탈중앙성 특성과 아주 잘 맞는다.

#### 스마트 컨트랙트의 동작 방식

```solidity
if or when(이벤트 x가 실행되면){ //조건
	액션 y를 실행 //계약 이행
}
```

코드가 블록체인 네트워크에 올라가면, 네트워크는 미리 결정된 조건이 충족되고, 검증된 경우 조건에 따른 액션을 실행한다. 이러한 액션은 트랜잭션에 기록되며, 완료된 트랜잭션은 블록체인에 올라간다. 스마트 컨트랙트는 한번 액션이 수행되면 되돌리거나 수정할 수 없다는 것을 의미한다.

따라서 스마트 컨트랙트는 당사자가 스마트 컨트랙트와 상호작용하는 방법을 정의하고, 누가, 언제, 어떤 입력이 어떤 결과를 초래하는지 담고 있다. 결과 값이 담겨있다는 것은 어떤 확률적인 상태(Probabilistic State)가 아니라, 조건에 따른 결과가 미리 결정되어 있다는 것을 의미한다.

코드에 따라 계약이 실행됨을 보장하는 결정론적인 상태(Deterministic State)인 다자간 디지털 계약이 바로 스마트 컨트랙트이다.

### 스마트 컨트랙트 장점

- 보안

  스마트 컨트랙트는 분산형 블록체인 인프라 위에서 실행되기 때문에, 한번 스마트 컨트랙트 코드가 블록체인 네트워크에 올라가면 모든 노드가 스마트 컨트랙트 내용과 이행 결과를 가지게 된다. 따라서 계약에 대한 중앙화된 공격 지점이 없고, 누군가에게 뇌물을 주고 계약 내용이나 결과를 변조할 위험이 없다.

- 신뢰성

  스마트 컨트랙트 로직이 조건에 부합해 계약이 이행되면 블록체인 네트워크에 있는 노드들에 의해 여러번 수행되고 검증되기 때문에, 위변조가 매우 어렵고 정확도가 높다.

- 공평함

  계약 조건을 공유하고 강제하기 위해 분산화된 블록체인 네트워크를 사용하기 때문에, 수수료를 가져가는 등 영리적 목적의 중개자가 필요하지 않다.

- 효율성

  계약 이행을 자동화하기 때문에 계약 당사자들은 수동으로 데이터를 입력하거나, 상대방의 계약 의미 이행 여부 검증하거나, 중개자가 계약을 집행하는지 확인할 필요가 없다.

### 한계점

1. 컨트랙트 배포 이후엔 작동 수정이 불가하다.

   내용을 수정할 수 없다는 것은 장점이 될 수 있고, 반대로 한계점이 될 수 있다. 만약, 배포한 컨트랙트에 보안 측면에서 허점이 발견될 경우 해킹에 취약하다.

2. 블록체인 외의 정보를 스스로 취득하지 못한다.

   블록체인 내부에 있는 정보 외의 정보는 스스로 취득할 수 없기에, 외부 데이터의 조건 충족을 확인할 때 문제가 발생한다. 이러면 제 3자에 의해 직접 데이터를 입력해야 한다. 외부 데이터를 가지고 온다고 하더라도, 전달 과정에서 오류가 나거나 악성 코드를 의도해서 입력하는 경우에도 문제가 발생할 수 있다.

## 비트코인에서의 스마트 컨트랙트

### UTXO 동작 원리

비트코인은 특정 지갑에 저장되는 것이 아닌 UTXO에 저장되며, 이 UTXO를 통해 코인의 존재 여부를 확인할 수 있다.

#### 트랜잭션 구조
<center>
<img src="../../images/2022-09-16-blockchain_24th/image-20220916142542364.png" alt="image-20220916142542364" style="zoom: 33%;" />
</center>
하나의 트랜잭션은 위와 같은 모양이며 다양한 데이터 구조들로 구성되어 있다.

- 트랜잭션 버전(Transaction Version)

  트랜잭션은 버전 별로 그 구조와 규칙이 조금씩 다르기 때문에 노드는 트랜잭션을 읽을때 버전 번호를 확인하고 트랜잭션을 어떻게 읽어야 하는지 파악할 수 있다.

- 잠금 시간(Lock Time)

  마지막 데이터는 잠금시간으로 트랜잭션을 블록체인에 바로 포함할 수 있는지, 아니면 지정된 시간이 지나면 포함할 수 있는지를 지정한다.

- 입력(Inputs)과 출력(Outputs)

  트랜잭션의 출력은 지폐를 사용하는 것과 같다. 5만원을 사용하면 2만원을 제한 3만원을 돌려받는다. UTXO도 동일하다.

  트랜잭션의 출력은 일종의 5만원권과 같다. 출력은 잠금(Lock)과 값(Value)으로 구성되어 있다. 출력은 기본적으로 잠겨있으며, 입력에는 잠금을 해제할 수 있는 키(Key)가 들어있다. 값은 출력 내에 잠겨있는 사토시(비트코인의 단위)의 양을 의미한다.

  트랜잭션 입력은 우리가 지불할 치킨값 2만원과 비슷하다. 포인터(Pointer)와 해제키(Unlocking key)가 들어있다. 포인터는 이전 트랜잭션 출력을 가리키며 키는 포인터로 가리키고 있는 이전 출력을 해제하는 데 사용된다. 그리고 남은 3만원은 돈을 지불한 사람에게 돌려주어야 하므로 새로운 출력을 만든다.

  출력에는 자산이 잠겨있고, 입력으로 출력을 해제하여 출력에 있는 값을 꺼내 새로운 출력에 자산을 담는다.

  트랜잭션에는 다른 곳에 잠겨있는 출력을 해제하는 입력과, 입력의 결과로 생긴 새로운 출력이 담기게 된다. 따라서 트랜잭션은 이전 출력을 해제하고, 새로운 출력을 만드는 추상적인 액션이라고 볼 수 있다. 이렇게 입력에 의해 생성된 후 다른 입력에 의해 해제되지 않은 트랜잭션 출력은 **UTXO**라고 한다.

### 비트코인 스크립트

비트코인에서는 **스크립트(Script)**라는 스크립터 언어를 사용해 스마트 컨트랙트를 구현한다. 일반적으로 비트코인에서 사용하는 스크립트는 비트코인 스크립트라고 부른다. 비트코인 스크립트는 일반적인 프로그래밍 언어와는 다르게 어떤 공식적인 문법이나 구문이 있는 것은 아니며 간단한 연산 목록으로 구성되어 있다. 스크립트에서 사용하는 연산들은 Opcode에 해당하며, 이 연산들은 C++로 작성되어 있다.

#### 입력값과 출력값
<center>
<img src="../../images/2022-09-16-blockchain_24th/image-20220916145608805.png" alt="image-20220916145608805" style="zoom:33%;" />
</center>
입력 구조

- Prev.Tx Id, TxIndex : 해제하고자 하는 이전의 출력을 가리키는 포인터
- ScriptSig : 이전의 출력을 해제하는 키

출력 구조

- ScriptPubkey : 잠금. ScriptPubkey의 소유자만이 ScriptSig를 만들수 있다.
- Amount : 잠김 비트코인의 양

노드는 피어로부터 트랜잭션을 받으면 먼저 해당 트랜잭션 안에 들어있는 입력과 출력 목록에서 각 입력과 출력에 해당하는 ScriptSig와 ScriptPubkeys를 추출한다.그리고 기존 블록들을 찾아보며 입력과 연결된 이전 출력을 찾고, 각 입력과 출력에 들어있는 ScriptSig와 ScriptPubkey를 연결한다.

ScriptSig와 ScriptPubkey는 각각 연속적인 정보를 담고 있다. 노드가 ScriptSig와 ScriptPubkey를 연결하고, 그 연결한 전체 시퀀스를 파싱하면 온전한 스크립트 코드가 나타나게 된다. 노드는 이 코드를 단계별로 실행한다.

#### 스크립트 동작 원리

스크립트는 역폴란드 표기법(Reverse Polish Notation)으로 작성된 스택 기반 튜링 불완전 언어이다.
<center>
<img src="../../images/2022-09-16-blockchain_24th/image-20220916150558424.png" alt="image-20220916150558424" style="zoom: 33%;" />
</center>
스크립트는 빈 스택에서 시작하며, 이 스택에서 데이터가 들어오거나(Push) 나가게 된다(Pop).

스크립트 프로그램은 두 종류의 객체를 가지고 있다.

- Opcode: 덧셈, 뺄셈, 곱셈과 같은 연산 작업을 나타낸다.
- 데이터: OP-CODE가 아닌 모든 데이터는 원시 데이터로 해석되며, 스택에 들어가게 된다.

스크립트는 이 Opcode와 Data를 일렬로 늘어놓은 것이다. 여기서 포인터는 일렬로 늘어진 Opcode와 데이터를 순서대로 하나씩 가리킨다. 만약 포인터가 데이터를 가리키면 데이터를 스택에 넣고, Opcode를 가리키면 스택에서 데이터를 꺼내온다.

스크립트 실행이 성공적이면 스택의 가장 상단에 요소는 1이된다. 만약 1이 아닌 다른값이면 스크립트 실행을 실패한 것으로 간주한다.

노드가 네트워크로부터 새로운 트랜잭션을 받으면, ScriptSig와 ScriptPubkey 필드를 추출하여 연결하여 최종적으로 ScriptSig, ScriptPubkey 형태의 스크립트를 얻게 된다. 노드는 이 스크립트와 빈 스택 하나를 사용해 스크립트를 실행하고 실행이 완료되면 최상위 스택 요소가 1인지 확인한다. 1이면 트랜잭션이 유효하다 간주하고 노드는 트랜잭션을 주변 노드들에게 전파한다. 반대이면 주변 노드들에게 트랜잭션을 보내지 않고 네트워크에 트랜잭션이 공유되지 않게 된다.

트랜잭션은 네트워크에 있는 모든 노드가 받을 수 있기 때문에, 네트워크의 모든 노드는 전체 네트워크의 상태를 지키는 문지기 같은 역할을 하게 된다.
<center>
<img src="../../images/2022-09-16-blockchain_24th/image-20220916151447166.png" alt="image-20220916151447166" style="zoom:33%;" />
</center>
### 자주 쓰이는 비트코인 스크립트

#### Pay To PubKey(P2PK)
<center>
<img src="../../images/2022-09-16-blockchain_24th/image-20220916154549026.png" alt="image-20220916154549026" style="zoom:33%;" />
</center>
ScriptPubkey는 잠금을 정의하는 데이터 구조이며, ScriptSig는 해제 키를 정의하는 데이터 구조이다. ScriptSig는 트랜잭션 입력(Input) 내부에 존재하며 ScriptPubkey는 이 트랜잭션 입력이 잠금을 해제하려는 이전 트랜잭션의 출력(Output)에서 추출된다.

"잠금을 해제한다"는 것은 ScriptSig와 ScriptPubkey를 연결하여 스크립트 코드로 만들어 실행하고, 실행 후 스택 최상단에 값이 1인 요소를 남기는 프로세스이다.

#### PayToPubKeyHash(P2PKH)
<center>
<img src="../../images/2022-09-16-blockchain_24th/image-20220916155229744.png" alt="image-20220916155229744" style="zoom:40%;" />
</center>
P2PK와는 다르게, 서명과 공개키가 ScriptSig에 들어있다. ScriptPubkey는 P2PK에서와 다르게 여러개의 Opcode를 가지고 있으며, 수신자의 공개키를 해싱한 값인 Hash 1 객체가 들어있다. 비트코인을 보내는 동안 송신자는 공개키의 해시값을 보내기 때문에 스크립트 이름의 PayToPubkeyHash인 것이다.

**비트코인 스크립트가 스마트 컨트랙트인 이유**

UTXO는 일종의 "계약"으로 정의될 수 있으며, 이 계약은 유효한 해제 조건을 주면 잠긴 비트코인을 이동시킨다. 오직 유효한 해제 조건을 줘야만 코인을 송금할 수 있는 계약인 것이다. 이 계약의 실행은 비트코인 네트워크가 보장하기 때문에 계약 이행을 강제하기 위한 중개자가 필요하지 않다.

### 비트코인 스마트 컨트랙트의 한계

비트코인은 최초의 블록체인 알고리즘이지만 확장성이나 성능 등의 한계가 존재했다. 오늘날에는 비트코인의 단점을 극복하기 위한 다양한 플랫폼과 프로젝트가 존재한다.

**라이트닝 네트워크(Lightning Network)**

비트코인의 거래량이 늘어날수록 처리해야 할 트랜잭션이 많아진다. 그런데 비트코인의 TPS는 트랜잭션 양과 관계없이 고정되어 있기 때문에 저장해야할 트랜잭션이 많아질수록 트랜잭션이 처리되는 속도가 느려지게 된다.

라이트닝 네트워크에서는 트랜잭션 내용은 블록체인 외부에 저장하고, 트랜잭션의 최종 결과만 블록체인에 올린다. 트랜잭션이 블록체인 바깥에서 이루어지기 때문에 트랜잭션이 처리되기까지 대기시간이 필요하지 않아 즉시 처리된다.

이러한 기능을 구현하기 위한 핵심 기술은 다중 서명(Multi Signature, Multi-Sig)과 시간 잠금 계약(Hashed Timelock Contract)이다.  
다중 서명을 통해 블록체인 외부에서 트랜잭션을 실행할 때는 계약 당사자들끼리 합의를 진행하고, 트랜잭션 결과를 체인에 기록할 때 계약 당사자들의 개인 키로 공동 계좌를 만들어 비밀 키를 생성한다. 또한 시간 잠금 계약은 일정 시간이 지나 트랜잭션이 확정되었을 때까지 트랜잭션을 변경할 수 없게 하여 계약 당사자가 트랜잭션을 임의로 수정하지 못하도록 한다.

**루트스탁(Rootstock, RSK)**

루트스탁은 비트코인에 스마트 컨트랙트 기능을 탑재하는 사이드체인 프로젝트이다. 비트코인에서도 스마트 컨트랙트 구현이 가능하지만, 기본적으로 연산에 대한 수수료가 비싸기 때문에 실질적으로는 사용이 어려웠다. 또한 비트코인 스크립트는 튜링 불완전하기 때문에 사용성 측면에서 제약이 컸다.

루트스탁은 2-Way peg를 이용해 비트코인에 튜링 완전한 스마트 컨트랙트를 지원하는 블록체인을 쌍방향으로 연결하며, 병합 채굴(Merge-Mining)을 통해 비트코인 채굴 노드가 사이드체인 블록까지 채굴할 수 있도록 연결한다. 이를 통해 비트코인 네트워크에서도 튜링 완전한 스마트 컨트랙트를 실행할 수 있게 되었다.

**탭루트(TapRoot)**

탭루트는 2021년 11월에 이루어진 비트코인 업그레이드를 의미한다. 탭루트에는 슈노르 서명과 MAST 등 중요한 사항들이 포함되어 있다.

슈노르 서명은 기존 다중 서명처럼 여러 개의 서명을 받는 것이 아니라, 여러개의 서명을 기반으로 한 하나의 공동 서명을 만들기 때문에 트랜잭션의 크기가 커지지 않는다.

MAST(Merkelized Abstract Syntax Tree, 머클 추상화 구문트리)는 비트코인 스크립트에서 해시값을 추출하는 자료구조로, 스크립트의 조건 중 필요한 부분만 먼저 검증할 수 있도록 하였다. 또한 MAST를 슈노르 서명과 결합하는 경우, 서명을 단 한번만 해도 트랜잭션이 이루어질 수 있기 때문에 속도가 개선되고, 효율성이 증대되는 효과가 있다.

## 이더리움에서의 스마트 컨트랙트

이더리움은 개발자들이 dApp을 만들 수 있도록 튜링 완전한 언어인 솔리디티(Solidity)를 제공하였으며, 이더리움 네트워크에 올라간 솔리디티 코드는 EVM을 통해 실행된다.

### EVM
<center>
<img src="../../images/2022-09-16-blockchain_24th/image-20220916161839461.png" alt="image-20220916161839461" style="zoom:50%;" />
</center>
EVM은 우리가 짠 코드와 이더리움 블록체인 사이에 있는 가상 머신으로, 블록체인에서 코드가 실행될 수 있도록 한다.

이더리움 스마트 컨트랙트에 기반한 dApp은 솔리디티라는 언어로 작성된다.  
우리는 솔리디티로 작성된 dApp을 이더리움 네트워크에 올려야 한다.

그런데 솔리디티 언어는 고급 언어이기 때문에 EVM이 바로 해석하기 어렵다.  
말 그대로 EVM은 가상 머신, 기계이기 때문에 언어를 바이트코드(bytecode)로 변환해주어야 한다.

이후 바이트 코드를 EVM이 해석할 수 있는 OP 코드로 변환하고, 그 이후 실행할 수 있다.

먼저 우리가 작성한 솔리디티 코드를 solc를 이용해 컴파일하여 EVM이 읽을 수 있는 바이트코드 형태로 만든다. 그리고 이 바이트코드를 Geth를 이용해 이더리움 네트워크에 올린다.

즉, **솔리디티 코드 -> 바이트 코드 -> Opcode** 흐름이다.

블록체인에 저장된 바이트코드 형태의 dApp은 EVM에서 실행하게 되며, EVM에서는 바이트코드를 Opcode로 변환하여 실행한다. 솔리디티로 작성된 스마트 컨트랙트는 EVM에서 동작하기 때문에 특정 운영체제나 하드웨어 종속되지 않는다.

### 솔리디티(Solidity)

솔리디티는 스마트 컨트랙트를 실행하는 객체 지향(Object-Oriented), 정적 타입(Static Typed), 고급(High-Level) 스크립트 언어로, EVM에서 실행된다.  
솔리디티는 컨트랙트 기반의 고급 프로그래밍 언어이다. C++과 파이썬, 자바스크립트를 기반으로 만들어졌으며, 이더리움 네트워크에서 스마트 컨트랙트를 생성할 수 있도록 설계되었다.  
솔리디티는 정적 타입 스크립트 언어이기에, 런타임 언어와는 달리, 컴파일 시 제약 조건을 확인하고 적용한다.

**솔리디티는 튜링 완전 언어이다.**

비트코인 스크립트와 비교해서 솔리디티의 가장 큰 특징은 튜링 완전/불완전이다.

비트코인 스마트 컨트랙트에서는 무한 반복 공격과 같은 보안상의 이슈를 고려해 의도적으로 반복문 Opcode를 제외했다. 따라서 비트코인 스크립트를 두고 튜링 불완전하다고 말한다.

이더리움의 핵심은 이러한 비트코인의 튜링 불완전성이라는 한계를 넘어, 개발자가 원하는 스마트 컨트랙트를 유연하게 구현할 수 있도록 튜링 완전을 제공하는 것이다. EVM은 반복문 Opcode들을 지원하는 대표적인 튜링 완전 머신이며, 솔리디티는 튜링 완전 머신을 동작하게 하는 튜링 완전 언어이다.

#### 솔리디티 개발 도구

dApp의 백엔드 개발도구들은 대표적으로 다음과 같은 것들이 있다.

- Remix IDE

  솔리디티를 사용한 dApp 개발을 도와주는 통합 개발 환경이다. Remix IDE는 자바스크립트로 만들어졌기 때문에 브라우저에서 사용가능하며, 로컬이나 데스크톱 버전을 사용할 수도 있다.

- solc

  솔리디티는 고급 언어이기 때문에 가상 머신인 EVM은 솔리디티를 읽을 수 없다. 따라서 솔리디티를 바이트코드로 컴파일해야 하는데 이때 사용하는 컴파일러이다.

- Ganache

  개발 단계에서 시뮬레이션 테스트 환경을 구성해주는 도구이다. 실제 이더리움 메인넷에서 테스트를 하기 위해서는 이더를 내야 하지만, Ganache를 사용하면 채굴없이 가상 이더리움 환경에서 트랜잭션 제한 없이 테스트를 할 수 있다.

- TestNet

  이더리움에서 제공하는 퍼블릭 테스트 네트워크이다. 테스트 네트워크는 실제 이더리움과 비슷하지만, 실제 트랜잭션이 이루어지지 않는다. 이더리움에는 현재 Ropsten, Kovan, Rinkeby 세개의 퍼블릭 테스트넷이 제공되고 있다.

- 프레임워크 : Truffle, Embark, Dapple

  솔리디티 코드를 이더리움 네트워크에 올리기 위한 여러 복잡한 과정을 해결해주는 다양한 프레임워크들이 있다. 이 프레임워크들은 솔리디티 코드에 대해 테스트, 디버깅, 컴파일, 배포를 제공한다.

### EVM의 내부 동작 구조

**이더리움은 상태 머신**

이더리움은 거래에 기반을 둔 상태머신이다. 상태 머신이란 일련의 입력을 읽고, 그 입력을 기반으로 새로운 상태로 전환하는 것을 의미한다.

이더리움이라는 상태 머신은 Genesis State에서 시작한다. 그리고 트랜잭션이 실행되면 다음 상태로 전환하게 된다. 더 이상 트랜잭션이 들어오지 않은 마지막 상태가 바로 이더리움의 현재 상태이다.

이더리움의 상태에는 수천개의 트랜잭션이 있다. 이 트랜잭션은 블록이라는 그룹에 묶여 있으며, 블록은 직전에 만들어진 블록과 이어져 있다.

#### EOA와 CA

이더리움에는 EOA(External Owned Account)와 CA(Contract Account)라는 두 종류의 계정이 있다. 모든 계정은 주소로 식별되며, 동일한 주소 공간을 가진다. EVM은 이 160bit 길이의 주소들을 처리한다.

EOA와 CA 모두 잔액(Balance), 논스(Nonce), 스토리지(Storage), 컨트랙트 코드(Contract Code)로 구성되어 있다.

- Balance : 계정의 현재 이더 잔고

- Nonce : EOA의 경우, 해당 EOA로부터 보내진 트랜잭션의 숫자, CA의 경우, 해당 CA로부터 생성된 컨트랙트의 숫자를 의미한다.
- StorageRoot : 머클 패트리샤 트리의 루트 노드를 해싱한 값이다.
- Contract Code : EVM이 실행할 코드의 해싱된 값. EOA에는 코드를 저장할 수 없기 때문에 비어있다.

EOA의 주소는 상응하는 비밀 키를 가지고 있지만, CA는 비밀 키가 없다.
<center>
<img src="../../images/2022-09-16-blockchain_24th/image-20220916170408633.png" alt="image-20220916170408633" style="zoom:50%;" />
</center>
또한 CA는 스스로 새로운 트랜잭션을 만들 수 없으며, CA는 EOA나 다른 CA에게서 방은 트랜잭션에 대한 응답에 대해서만 트랜잭션을 만들 수 있다.

따라서, 이더리움 블록체인에서 일어나는 모든 액션은 항상 EOA에서 만든 트랜잭션에서부터 시작한다.

#### 전역 상태

이더리움의 전역 상태는 계정 주소와 계정 상태를 매핑한 것으로 구성되어 있다. 이 매핑은 머클 패트리샤 트리형태로 저장되어 있다.

트리 맨 아래에 있는 데이터는 저장하려는 데이터를 청크(Chunk)로 분할한 다음, 각 청크를 두 개씩 모아 해시를 취하여 부모 노드를 만든다. 그렇게 하나의 루트 노드가 만들어질 때까지 동일한 과정을 반복한다.

이더리움의 블록 헤더에는 세 개의 머클 트리 구조의 루트 노드의 해시값이 저장되어 있다.

1. 상태 트리(State Tree) : 트랜잭션과 연관된 계정의 상태 정보 저장
2. 트랜잭션 트리(Transaction Tree) : 현재 블록의 트랜잭션 정보 저장
3. 영수증 트리(Receipt Tree) : 현재 블록의 거래 영수증 정보 저장
<center>
<img src="../../images/2022-09-16-blockchain_24th/image-20220916170856894.png" alt="image-20220916170856894" style="zoom:33%;" />
</center>
머클 패트리샤 트리에서 변조가 시도되면 그 즉시 발견된다. 따라서 루트 노드는 데이터에 대한 보안 ID처럼 사용될 수 있다. 또한 블록 헤더는 상태, 트랜잭션, 영수증 트리의 루트 노드 값을 가지고 있기 때문에, 네트워크의 노드들은 모든 상태를 저장하고 있지 않더라도 이더리움의 상태 일부분을 검증할 수 있다.

#### 트랜잭션과 메시지

기본적으로 트랜잭션은 EOA에서 생성되고, 일련의 과정을 거쳐 블록체인에 올라간 **암호화 서명된 명령어의 집합**이다.

그 외의 트랜잭션은 **메시지 호출(Message Call)**과 **컨트랙트 생성(Contract Creations)** 두 종류로 나뉜다.

이더리움의 모든 트랜잭션은 항상 EOA에서 만들어지고 블록체인에 올라간다. 즉, 트랜잭션은 외부 세계를 이더리움 내부의 상태로 연결해주는 다리와 같다. 그리고 연결의 창구가 바로 CA이다.

이더리움 전역 상태에 있는 CA는 메시지(Message)나 내부 트랜잭션(Internal Transaction)을 통해 다른 CA와 상호작용 할 수 있다. 메시지와 내부 트랜잭션은 일반적인 트랜잭션과 비슷하지만 EOA에서 생성되지 않으며, 오로지 CA에서만 생성된다. 또한 일반적인 트랜잭션과는 다르게 미시지와 내부 트랜잭션은 EVM에만 존재하는 가상 객체이다.

한 CA가 다른 CA에 내부 트랜잭션을 보내면 수신하는 CA에 있는 관련 코드가 실행된다.
<center>
<img src="../../images/2022-09-16-blockchain_24th/image-20220916171454006.png" alt="image-20220916171454006" style="zoom:33%;" />
</center>
#### CA 생성

새로운 CA를 만들기 위해서는 먼저 특별한 공식을 이용해 새로운 계정의 주소를 정의해야 한다. 그리고 다음의 과정을 통해 새로운 CA를 만들 수 있다.

1. 논스를 0으로 설정한다.
2. 송신자가 CA 생성 트랜잭션에 이더를 함께 보낸 경우 이를 CA의 잔금(Balance)으로 설정한다.
3. 잔금에서 Value 만큼을 제외한다.
4. CA의 스토리지를 빈 값으로 초기화한다.
5. CA의 코드를 빈 문자열의 해시값으로 초기화한다.

한번 계정을 초기화하고 나면, 트랜잭션에서 보낸 init코드를 사용해 새로운 CA를 생성할 수 있다. init코드가 실행되는 동안에는 계약 생성자에 따라 CA의 스토리지를 업데이트하거나, 다른 CA를 새롭게 생성하거나, 다른 메시지 호출을 만들 수 있다.

계약을 초기화하는 이 init코드를 실행할 때는 가스를 사용한다. 트랜잭션은 남아 있는 가스보다 더 많은 가스를 소비할 수 없기 때문에, 만약 남아있는 가스를 다 사용한 경우 OOG(Out-of-Gas) 예외 처리와 함께 코드 실행이 종료된다. OOG로 인한 트랜잭션 종료가 발생하면 상태는 트랜잭션 실행 이전 상태로 돌아간다.

트랜잭션이 실패해도 트랜잭션 송신자는 소진된 가스를 환불받을 수 없다. 그러나 송신자가 트랜잭션과 함께 이더 값을 보낸 경우, 이더는 환불된다.

init 코드가 성공적으로 실행되면, 마지막으로 CA코드에 대한 비용이 지불된다. 이 비용은 스토리지 비용이며, 생성된 CA 코드의 크기에 비례한다. 만약 CA 코드에 대한 비용을 지불할 가스가 남아있지 않은 경우, 트랜잭션은 OOG 예외와 함께 중단된다. 예외없이 트랜잭션 생성이 완료된 경우, 미사용된 가스는 송신자에게 환불되고, 변경된 상태가 저장된다.

#### 메시지 호출(Message Call)

메시지 호출은 새 계정이 생성되지 않기 때문에 메시지 호출 실행에는 init코드가 포함되지 않는다. 그러나 입력 데이터를 가지고 있을 수는 있다. 메시지 호출은 한번 실행되면 출력 데이터를 포함한 추가적인 요소들을 가지게 될 수도 있는데, 이 추가 요소들은 뒤에 이어질 다른 실행에 필요한 데이터이다.

CA생성과 마찬가지로 메시지 호출을 실행할 때 가스가 부족하거나 트랜잭션이 잘못되어 종료되는 경우 사용된 가스는 환불되지 않는다. 남은 가스는 모두 소비되며, 상태는 직전 상태로 돌아간다.

#### 트랜잭션 실행 모델과 EVM

트랜잭션 처리를 실제로 처리하는 프로토콜은 EVM이다.

EVM의 구성 요소

- 스택

  EVM은 비트코인 스크립트와 마찬가지로, 스택 기반 아키텍쳐를 갖고 있다. EVM 내에는 하나의 빈 스택이 있으며, 스택에 들어가는 요소의 크기는 256bit이며 스택의 최대 크기는 1024 bit이다.

- 메모리

  EVM은 메모리를 가지고 있으며, 메모리에서는 Word-Address 형식의 바이트 배열로 데이터를 저장한다. 메모리는 휘발성이기 때문에 프로그램이 종료되면 메모리에 들어있는 데이터는 사라진다.

- 스토리지

  메모리와 다르게 스토리지는 비휘발성이며 시스템 상태에 따라 유지된다. EVM은 특정한 명령어로만 접근할 수 있는 가상 ROM 이라는 공간에 프로그램 코드를 분리해서 저장해둔다.
  <center>
  <img src="../../images/2022-09-16-blockchain_24th/image-20220918161336948.png" alt="image-20220918161336948" style="zoom:33%;" />
  </center>
EVM이 솔리디티 코드를 컴파일한 바이트코드를 받으면 실행이 시작된다. 맨 처음에는 메모리와 스택은 비어있으며, 프로그램 카운터(연산 실행 횟수)는 0이다.

```
PC(Program Counter) : 0
Stack : []
Memory : []
Storage : {}
```

EVM은 트랜잭션을 반복적으로 실행하며 각 사이클에서 시스템 상태(이더리움의 전역 상태)와 머신 상태(Machine State)를 계산한다.

머신 상태는 다음과 같이 구성된다.

- 사용 가능한 가스
- 프로그램 카운터
- 메모리에 들어있는 값
- 메모리에서 활성화된 단어의 수
- 스택에 들어있는 값

코드가 실행되면서 스택에 있는 요소들은 왼쪽에서부터 순서대로 추가되거나 제거되며, 남은 가스에서 적절한 양의 가스가 제거되고, 프로그램 카운터가 올라간다.
<center>
<img src="../images/2022-09-16-blockchain_24th/image-20220918161747999.png" alt="image-20220918161747999" style="zoom: 33%;" />
</center>
매 사이클이 끝날 때 다음과 같은 세가지 케이스가 발생할 수 있다.

1. EVM이 예외 상황을 만나 중지되고, 변경 사항은 폐기된다.
2. 다음 사이클을 돌아야 하는 경우
3. 머신이 프로세스 실행을 끝낸 경우

머신이 정상적으로 실행을 마치면, 결과적으로 발생한 상태와 남아있는 가스, 발생한 세부 상태, 결과값을 생성한다.

### 스마트 컨트랙트의 실행 비용

이더리움에서 트랜잭션의 결과로 발생하는 모든 연산은 수수료를 요구하며 이 수수료를 가스(Gas)라고 한다.

가스는 트랜잭션 코드에 있는 모든 Opcode를 실행하는데 필요한 수수료를 측정하는데 사용하는 단위이다. Gas Price는 가스당 지불하려고 하는 이더의 양을 의미하며, Gwei라는 단위를 사용한다.

1 이더 = 10^18 wei 이며, 1 Gwei = 10^9 wei 이다.

트랜잭션 송신자는 Gas Limit과 Gas Price를 트랜잭션에 지정한다.

Gas Limit은 송신자가 지불하고자 하는 가스의 최댓값을 의미한다. 만약 CA에 이 최대치를 지불하고도 남을 충분한 이더가 들어있다면 트랜잭션은 문제없이 실행된다. 송신자는 트랜잭션이 완료된 후 사용되지 않은 가스를 기존 비율로 환불받는다.
<center>
<img src="../../images/2022-09-16-blockchain_24th/image-20220918163039817.png" alt="image-20220918163039817" style="zoom:50%;" />
</center>
#### 스토리지 수수료

스토리지를 사용할 때도 수수료를 내야한다. 스토리지의 최종 수수료는 32바이트 단위에 비례한다.

스토리지가 증가하면 모든 노드에서 이더리움 상태 데이터베이스의 크기가 커지기 때문에 데이터의 양을 최대한 적게 유지할수록 인센티브를 부여한다. 이러한 이유로 만약 트랜잭션이 스토리지에 있는 특정 요소를 지우는 연산을 수행하면, 해당 연산을 수행하는 데에 대한 수수료는 면제하고, 저장 공간을 확보했기 때문에 기존에 요소를 스토리지에 추가했을 때 지불했던 가스를 환불받는다.

예를 들어 스토리지에 요소 하나를 할당했을때 100 Gas를 지불한다고 가정한다. 트랜잭션에서 스토리지에 요소 하나를 할당하여 100 Gas를 지불한다. 이후 해당 요소를 다시 스토리지에서 제거하는 연산을 수행할 때는 제거 연산에 대한 수수료는 0 Gas이며, 더 이상 스토리지 자리를 차지하지 않기 때문에 할당할 때 들었던 100 Gas를 환불해준다.

#### 수수료를 지불하는 이유

이더리움은 튜링 완전 언어이기 때문에 반복문을 지원한다. 하지만 무한 루프 문제라는 단점이 있어서 악용될수 있기 때문에 수수료를 이용한다. 연산마다 쑤료를 부과하면 악의적인 사용자라도 수수료를 지불해야하므로 쉽게 무한 루프 코드를 실행시킬 수 없다. 또한 의도치않게 무한 루프를 만든 코드를 실행시키더라도 Gas Limit을 설정해두면 지정해둔 가스를 다 소모하기 전에 실행을 멈출 수 있다.