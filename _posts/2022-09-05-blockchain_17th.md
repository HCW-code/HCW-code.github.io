---
layout: single
title: "[블록체인] DAG, DHT"
categories: blockchain
tag: [dag, dht]
toc: true
---

## 암호화폐에서의 DAG(Directed Acyclic Graph)

### 암호화폐에서의 DAG

일반적으로 암호화폐 플랫폼에서는 데이터 구조로 블록체인을 사용하지만, 블록체인 대신 DAG를 사용하는 경우도 있다.
<center>
<img src="../../images/2022-09-05-blockchain_17th/image-20220905152324567.png" alt="image-20220905152324567" style="zoom: 33%;" />
</center>
일반적인 블록체인에서는 각 정점이 "블록"으로 구성되어 있는 블록 안에 트랜잭션이 담겨있다.

기차 같이, 특정 시간대에 역에 들어와 짐을 싣고 이동하는 것과 같다. 만약 짐이 제시간에 역에 도착하지 않은 경우 다음 기차가 오길 기다려야 한다는 단점이 있다.

### DAG의 동작 방식

DAG는 "블록" 개념이 존재하지 않으며, 그래프의 각 정점은 블록이 아닌 개별 트랜잭션이다.  
따라서, 블록 개념이 없기 때문에 채굴 과정도 필요하지 않다. 대신, 트랜잭션들은 서로를 참조함으로써 해당 트랜잭션의 유효성을 검증한다.

DAG에서는 어떻게 네트워크의 트랜잭션의 유효성 검사 방법

1. 노드가 트랜잭션을 네트워크에 제출한다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905153123753.png" alt="image-20220905153123753" style="zoom: 33%;" />
</center>
2. 새로운 트랜잭션은 네트워크 내에 있는 이전 트랜잭션을 참조해야 네트워크에 승인되기 때문에, 이전 트랜잭션을 찾는다.

   이전 트랜잭션은 꼭 직전에 올라온 트랜잭션이 아니어도 된다.  
   일부 시스템에서는 새로운 트랜잭션이 더 많이 검증된 트랜잭션을 선택하는 알고리즘을 사용하도록 한다.  
   더 많이 검증된 트랜잭션을 채택하도록 하므로 시스템은 안전하게 성장하게 된다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905153146287.png" alt="image-20220905153146287" style="zoom: 33%;" />
</center>
3. 이전 트랜잭션을 찾았다면, 해당 트랜잭션의 유효성을 검사한다.

   해당 트랜잭션의 송신자가 충분한 잔고를 가졌는지 확인하기 위해 그래프의 가장 처음 트랜잭션까지의 경로로 올라가면서 해당 트랜잭션이 유효한지 확인한다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905153355988.png" alt="image-20220905153355988" style="zoom: 33%;" />
</center>
   만약 해당 트랜잭션이 유효하지 않다면 새로운 트랜잭션은 이 트랜잭션을 참조하지 않고, 다른 이전 트랜잭션을 참조한다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905153433598.png" alt="image-20220905153433598" style="zoom: 33%;" />
</center>
   블록체인에서 이중 지불을 방지하는 다양한 메커니즘이 있는 것처럼, DAG에서는 자신이 참조하는 트랜잭션의 전체 경로를 확인하고 잔고가 충분한지 트랜잭션을 검증함으로써 이중 지불을 방지한다.

4. 이렇게 한다고 해서, 새로운 트랜잭션이 승인되는 것은 아니다. 해당 트랜잭션이 승인되기 위해서는 이후 새로운 트랜잭션이 해당 트랜잭션을 참조하여 유효성을 검사해주어야 하며 참조되기 전까지는 유효한 트랜잭션으로 승인 된 것은 아니다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905153858802.png" alt="image-20220905153858802" style="zoom:50%;" />
</center>
   가령 앞의 그림에서 제출한 새로운 트랜잭션이 참조한 트랜잭션의 경우, 우리 트랜잭션에 의해 참조되었기 때문에 "승인"된 것이다.

### DAG의 특징

**트랜잭션 처리 속도**

블록체인은(비트코인 기준) 블록 생성이 10분에 한번씩 이루어지기 때문에 트랜잭션이 체인에 올라가기까지 약 10분이 소요되며, 해당 트랜잭션이 완전히 처리되기까지는 1시간이 걸린다.

반면, DAG는 블록 개념이 없고, 트랜잭션이 선형적으로 처리되는 것이 아니라, 병렬적으로 처리되기 때문에 블록체인과 비교했을 때 빠른 속도로 트랜잭션이 처리된다.

**채굴이 없다**

DAG의 경우, 채굴 과정 자체가 없기 때문에 채굴자에게 내야할 수수료도 없다.

또한 작업 증명으로 인한 과도한 에너지 사용도 없기 때문에 환경친화적이기도 하다.

**확장성 문제에서 비교적 자유로움**

DAG는 트랜잭션이 늘어날수록 새로운 트랜잭션들이 이전 트랜잭션을 많이 검증할 수 있기 때문에 확장성 문제에서 자유롭다.

또한 앞서 말했던 것처럼 트랜잭션 처리 속도 역시 매우 빠른 편이기도 하다.

## DHT

### 해시 테이블
<center>
<img src="../../images/2022-09-05-blockchain_17th/image-20220905155109382.png" alt="image-20220905155109382" style="zoom:33%;" />
</center>
hash table이란 키를 입력값으로 해시함수를 사용하여 변환한 해시(hash)값을 색인(index)으로 삼아 키(key)와 데이터(value)를 저장하는 자료구조이다.

이 해시테이블은 쉽게 핸드폰으로 통화를 하기 위해 단축번호를 설정하여 사용하는 것과 같다고 생각하면 된다.

#### Hash Table의 구조

- 키(key) : 고유한 값으로 해시 함수의 입력값이 된다. 다양한 길이의 값이 들어올 수 있다. 해시 함수를 통해 변환하지 않은 상태로 저장소에 저장이 되면 다양한 길이만큼의 저장소를 구성해두어야 하므로 해시 함수로 값을 바꾸어 저장하게 된다.
- 해시함수(hash function) : 키를 해시로 바꿔주는 역할을 한다. 다양한 길이의 키를 일정한 길이를 가지는 해시로 변경하여 저장소를 효율적으로 운영할 수 있도록 해준다. 다만, 서로 다른 키가 같은 해시가 되는 경우가 해시 충돌이라고 하는데, 해시 충돌을 일으키는 확률을 최대한 줄이는 것이 중요하다.
- 해시(hash) : 해시 함수를 사용하여 만들어진 결과물로, 저장소에서 데이터와 매칭되어 저장된다. 변환된 값을 배열의 색인(index)과 같이 사용하게 된다.
- 데이터(value) : 저장소에 최종적으로 저장되는 값으로 색인(index)과 매칭되어 저장된다.

#### Hash Table의 특징

1. **저장, 삭제, 검색 과정**

   hash table에서 값을 저장, 삭제, 검색하기 위해서는 해시 함수(hash function)에 키(key)값을 넣어 해시(hash)값을 만들게 된다. 이후 만들어진 해시 값과 일치하는 색인(index)을 찾아 저장하거나 삭제, 검색한다.

2. **대표적인 해시 알고리즘**

   - **Division Method** : Number type의 키(key)를 저장소의 크기로 나누어 나온 나머지를 색인(index)으로 사용하는 방법이다. 이때 저장소의 크기를 소수(Prime Number)로 정하고 2의 제곱수와 먼 값을 사용하는 것이 효과가 좋다. 예를 들어 Key 값이 23일 때 색인(index)가 저장소의 크기를 넘어간다면 Division Method를 적용할 수 있다.
   - **Digit Folding** : 키(key)의 문자열을 아스키코드로 바꾸고 그 값을 합해 저장해소에서 색인(index)으로 사용하는 방법이다. 만약 이때 색인(index)가 저장소의 크기를 넘어간다면 Division Method를 적용할 수 있다.
   - **Multiplication Method** : 숫자로 된 Key 값 K와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같이 계산한 값을 사용한다. Index = (KA mod 1)m
   - **Universal Hashing** : 다수의 해시함수를 만들어 특정한 장소에 넣어두고, 무작위 해시함수를 선택해 해시(hash)값을 만드는 기법이다.

3. **해시 충돌을 해결하는 방법**

   - 개방 연결법
     - Linear Probing
     - Quadratic Probing
     - Double Hashing Probing
   - 분리 연결법

### DHT(Distributed Hash Table)

#### DHT(Distributed Hash Table)

DHT(분산 해시테이블)는 해시 테이블을 활용해, 키-값 쌍 방식으로 데이터를 검색하는 분산형 데이터베이스이다. DHT는 Peer-to-Peer 환경에서 데이터를 분산하여 저장할 때 사용한다.

#### DHT에 데이터를 저장하는 방법

1. 다음과 같은 해시테이블이 있다고 가정한다. 이 해시 테이블의 범위는 0부터 7까지입니다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905190356291.png" alt="image-20220905190356291" style="zoom:33%;" />
</center>
2. 그리고 이 테이블을 4명의 호스트가 사용한다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905190416810.png" alt="image-20220905190416810" style="zoom:33%;" />
</center>
   호스트들은 각각 공유해야할 데이터를 갖고있다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905190502844.png" alt="image-20220905190502844" style="zoom:33%;" />
</center>
3. 이제 각 해시테이블의 인덱스에 호스트의 IP 주소를 넣는다.

   정해진 해시테이블의 인덱스 안에 호스트의 주소를 할당하기 위해, 호스트의 IP주소를 해싱하여 해싱한 결과값을 8로 나눈 나머지 값을 인덱스로 한다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905190747694.png" alt="image-20220905190747694" style="zoom:33%;" />
</center>
   이 호스트들은 자신 다음에 있는 호스트 중 가장 가까이에 있는 호스트의 IP주소를 알게 된다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905190836513.png" alt="image-20220905190836513" style="zoom: 33%;" />
</center>
   

4. 해시 테이블에 인덱스에는 호스트의 IP주소 외에도, 데이터의 위치를 저장한다.

   각 호스트는 공유해야 하는 파일을 가지고 있었다.

   이 파일들 역시 IP주소를 해싱하여 인덱싱했던 것처럼 동일한 방식으로 해싱한다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905191328673.png" alt="image-20220905191328673" style="zoom:33%;" />
</center>
   이렇게 나온 새값을 그대로 해시 테이블에 인덱싱한다.

   가령, '기획서.hwp'의 해시값은 5이므로, 해시테이블의 인덱스 5에 있는 호스트인 789.0.5.4는 "기획서.hwp"는 123.0.20.8에 있다라는 것을 기억하게 된다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905191524105.png" alt="image-20220905191524105" style="zoom:33%;" />
</center>
   카카오톡.exe의 해시값은 7이지만 7번 인덱스에는 호스트가 없기 때문에, 가장 인접한 호스트인 101.0.234.5가 카카오톡.exe의 위치를 저장한다.

#### DHT가 데이터를 찾는 법

456.0.13.2 컴퓨터가 "카카오톡.exe" 파일을 찾는다
<center>
<img src="../../images/2022-09-05-blockchain_17th/image-20220905194740376.png" alt="image-20220905194740376" style="zoom:33%;" />
</center>
1. 456.0.13.2는 자신의 가장 가까운 컴퓨터인 123.0.20.8에게 묻는다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905194757007.png" alt="image-20220905194757007" style="zoom:33%;" />
</center>
2. 123.0.20.8은 "가계부.csv"의 위치는 알지만, "카카오톡.exe"의 주소는 모른다. 따라서 자신의 가장 가까운 컴퓨터인 789.0.20.8에게 "카카오톡.exe"가 어디 있냐고 묻는다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905194818936.png" alt="image-20220905194818936" style="zoom:33%;" />
</center>
3. 789.0.20.8 도 모르기 때문에 자신의 가장 가까운 다음 컴퓨터에게 물어본다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905194840444.png" alt="image-20220905194840444" style="zoom:33%;" />
</center>
4. 101.0.234.5는 "카카오톡.exe"가 어디있는지 알기 때문에 처음 질문했던 456.0.13.2에게 "카카오톡.exe"의 위치를 알려준다.
<center>
   <img src="../../images/2022-09-05-blockchain_17th/image-20220905194905817.png" alt="image-20220905194905817" style="zoom:33%;" />
</center>