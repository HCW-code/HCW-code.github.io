---
layout: single
title: "[블록체인] IPFS, 프루닝"
categories: blockchain
tag: [ipfs, pruning]
toc: true
---

## IPFS

IPFS(InterPlanetary File System)는 Git, BitTorrent, Kademlia, Bitcoin 등과 같은 서비스에서 영감을 받아 시작한 무료 오픈 소스 프로젝트이다.

- 분산형 파일 시스템에 데이터를 저장하고 인터넷으로 공유하기 위한 프로토콜
- P2P(peer-to-peer) 네트워크

기존의 HTTP 프로토콜 방식은 데이터가 위치한 곳의 주소를 찾아가서 요청한 콘텐츠를 한번에 가져오는 방식이었지만, IPFS는 전세계 여러 컴퓨터에 분산 저장된 각 데이터 조각으로 잘게 나눠서 가져온 후 하나로 합쳐서 보여주는 방식으로 동작한다.

### IPFS란

IPFS는 프로토콜이자 파일 시스템, 웹, 모듈러, 암호화, p2p, CDN, 네임서비스 모든 것을 아우릅니다.

프로토콜

- content-addressed 파일 시스템
- 콘텐츠 전달
- Kademlia + BitTorrent + Git 결합

파일 시스템

- 디렉토리, 파일 기반
- 마운트 가능한 파일 시스템(FUSE를 통해)

웹

- 전통적인 웹과 같이 문서를 보는데 사용 가능
- HTTP를 통해 파일에 액세스 가능
- 브라우저 및 확장 프로그램은 ipfs:// 또는 dweb:/ipfs/ 의 URL, URI 스키마를 직접 사용하는 방법을 학습 가능
- Hash-addressed 콘텐츠가 신뢰성을 보장

모듈러

- 모든 네트워크 프로토콜의 연결 계층
- 라우팅 레이어
- DHT(Kademlia/Coral) 라우팅 레이어 사용
- 경로 기반 네이밍 서비스 사용
- BitTorrent에서 차용한 블록 교환 사용

암호화

- 각 콘텐츠에 암호화 해시 주소 지정
- 블록 수준 중복 제거
- 파일 무결성 및 버전 관리
- 파일 시스템 수준에서 암호화 및 서명 지원

p2p

- 전 세계 peer-to-peer 파일 전송
- 완전한 분산 아키텍처
- 중앙 실패 지점 없음

CDN

- 로컬에서 파일을 추가하면 전 세계에서 사용 가능
- 캐싱 친화적
- BitTorrent 기반의 네트워크 대역폭 분포

네임 서비스

- SFS에서 영감받은 네임 서비스, IPNS
- PKI(공개키 암호화)기반 글로벌 네임스페이스
- 신뢰 사슬 구축
- 다른 NS서버와 호환
- DNS, .onion, .bit 등을 IPNS에 매핑 가능
<center>
<img src="../../images/2022-09-06-blockchain_18th/image-20220906124351696.png" alt="image-20220906124351696" style="zoom:50%;" />
</center>
IPFS를 사용하게 되면 해당 컴퓨터는 필요한 파일들을 다운받는 것과 동시에 파일들을 나누어 주는 역할을 한다.

### IPFS 특징

- 분산화(Decentralization)
- 콘텐츠 어드레싱(content-addressing)
- 참여(Participation)

#### 분산화

- **안정적인 인터넷을 지원한다** : 중앙 서버에 오류가 생기면 파일 다운로드가 불가능한 기존의 구조 대비 다른 곳에서 동일한 웹 페이지를 얻을 수 있다.
- **콘텐츠를 검열하기 어렵게 한다** : 파일이, 분산된 환경에서 전달된다는 특성으로 인해 위와 같이 특정 정보에 접근하는 것을 막거나 검열하는 검열하는 것을 어렵게 한다.
- **웹 속도를 높일 수 있다** : 요청하는 컴퓨터가 멀리 떨어져 있거나 인터넷이 연결되지 않은 상황에서도 주변의 가까운 피어에서 빠르게 파일을 받아올 수 있다.

#### 콘텐츠 어드레싱

/ipsf/qevionq12312evilqenfvique45345vfvq6efvqeoifvnqeoivfn/wiki/Codestates.html

콘텐츠 어드레싱이란 쉽게 이야기하면 콘텐츠를 주소 기반으로 표현한다는 것이다.

IPFS 콘텐츠의 URL은 위와 같은 형태이다.

/ipfs/ 다음의 문자열을 콘텐츠 식별자(content identifier, CID)라고 하며 이를 통해 여러 피어로부터 콘텐츠를 가져올 수 있따.

- Https://en.wikipedia.org/wiki/Codestates
- /Users/Codestates/Document/codestates_content.doc

위와 같은 전통적인 URL 또는 파일 경로는 해당 위치를 기반으로 파일을 식별한다.

하지만 이와 달리 IPFS는 파일에 포함된 내용을 기준으로 파일의 주소를 식별한다.  
위에서 콘텐츠 식별자는 해당 콘텐츠 내용의 해시 값이다.

해시는 콘텐츠마다 고유하다는 특성이 있어서 식별이 가능하다.

- 웹 페이지의 텍스트가 변경되면 새 버전은 새롭고 다른 주소를 갖게 된다.
- 콘텐츠를 다른 주소로 이동할 수 없다.

하지만 매번 콘텐츠가 업데이트되거나 변경될때마다 새로운 링크를 보내는 것은 비효율적이기 때문에 IPNS, MFS(Mutable File System) 및 DNSLink를 참고해서 보완이 가능하다.

#### 참여

IPFS의 기본적인 아이디어는 사람과 컴퓨터가 통신하는 방식을 바꾸는 것이다.

오늘날의 웹(www)은 소유권과 액세스를 기반으로 구성되어 있어서 파일을 소유한 사람이 액세스 권한을 부여하기로 한 경우에만 파일을 받을 수 있다.

반면 IPFS는 소유와 참여를 기반으로 동작하며, 많은 사람이 서로의 파일을 소유하고 사용 가능하게 만드는데 초점을 둔다.

즉, IPFS는 사람들이 적극적으로 참여한다는 가정하에만 정상적으로 작동한다.

### IPFS 동작 방식

1. 콘텐츠 어드레싱을 통한 고유 식별
2. 방향성 비순환 그래프(DAG)를 통한 콘텐츠 연결
3. 분산 해시 테이블(DHT)을 통한 콘텐츠 검색

**콘텐츠 어드레싱**

IPFS는 파일의 내용을 해시화하여 콘텐츠 식별자(CID)를 생성한다.

해시는 원본 콘텐츠에 비해 짧아 보일 수 있지만 기원한 콘텐츠에 대해 고유한 값이다.

다른 많은 분산 시스템도 해시를 통해 콘텐츠 식별뿐만 아닌 함께 콘텐츠를 서로 연결하는 수단으로 사용한다.

하지만 이러한 시스템의 기본 데이터 구조는 상호 운용 가능하지 않고 서로 연동되지 못하기도 해서 이러한 문제를 해결하기 위해 IPLD이라는 프로젝트가 시작되었따.

IPLS는 해시 연결 데이터 구조 사이를 변환하여 분산 시스템 전반에 걸쳐 데이터를 통합할 수 있도록 한다.

**방향성 비순환 그래프(DAG)**

IPFS 및 다른 많은 분산 시스템은 DAG 자료 구조를 사용한다.

특히 각 노드에는 노드 콘텐츠의 해시가 있는 Merkle DAG를 사용한다.

IPFS는 디렉터리와 파일을 나타내는 것에 최적화된 Merkle DAG를 사용하는데, 이때 다양한 방법으로 Merkle DAG를 구성할 수 있다.

콘텐츠를 하나의 Merkle DAG로 만들기 위해서는 먼저 콘텐츠를 블록 단위로 분할해야 한다.

콘텐츠를 블록들로 나누어서 두개의 유사한 파일이 있는 경우 Mekle DAG의 일부를 공유할 수 있게 된다.

즉, 다른 Merkle DAG의 일부가 동일한 데이터 하위 집합을 참조할 수 있다.

이렇게 하면 매번 완전히 새로운 파일을 만드는 대신 새롭거나 변경된 부분만 전송받을 수 있다.
<center>
<img src="../../images/2022-09-06-blockchain_18th/image-20220906130742368.png" alt="image-20220906130742368" style="zoom:50%;" />
</center>
Merkle DAG에서 모든 것은 CID가 있다.

폴더 그 자체, 폴더에 있는 파일들, 해당 파일은 블록까지 모두 CID를 가진다.

요약하면 IPFS는 콘텐츠에 CID를 부여하고 Merkle DAG를 통해 해당 콘텐츠를 함꼐 연결할 수 있다.

**분산 해시 테이블(DHT)**

어떤 피어가 콘텐츠를 호스팅하고 있는지 탐색하기 위해 IPFS는 분산 해시 테이블(DHT)을 사용한다.

해시테이블은 키와 값으로 구성된 데이터베이스이다.

IPFS는 DHT를 제공하고 서로 연결하고 소통하는 피어를 처리하기 위해 libp2p라는 프로젝트를 제공한다.

콘텐츠를 찾고 해당 콘텐츠의 현재 위치를 알아냈다면 이제 해당 콘텐츠의 내용을 가져와야한다. 따라서 내용을 보기 위해서는 총 두번의 쿼리가 필요하다.

(피어의 현재 위치 찾기 -> 콘텐츠 내용 찾기)

다른 피어에게 블록을 요청하고 블록을 보내기 위해서는 Bitswap 이라는 모듈을 사용한다.

Bitswap을 사용하면 원하는 콘텐츠를 가지고 있는 피어에 연결하고 원하는 목록(관심 있는 모든 블록 목록)을 보내고 요청한 블록을 받을 수 있도록 한다.

요청한 블록이 도착하면 원하는 콘텐츠를 해시하여 CID를 얻고 이를 요청한 CID와 비교함으로써 정확한 데이터를 받았는지 검증할 수 있다.

- Bitswap과 더불어서 Graphsync와 같은 다른 복제 프로토콜도 논의하고 있다.

## 프루닝(Pruning)

프루닝(Pruning)은 경량화 기법의 하나로, 인공 지능(딥러닝)분야에서 검색 모델을 학습한 후에 불필요하거나 중요도가 낮은 노드 등을 제거하는 기술

### 비트코인 프루닝

비트코인의 노드는 블록체인의 사본을 보관하고 네트워크를 실행하는 데에 필요한 여러 태스크를 수행한다. 그러나 하나의 문제가 있다면, 많은 스토리지를 낭비한다는 것이다. 이 행위는 노드의 디스크 공간의 차지와 노드를 시작할 때 터무니없이 느린 인터넷 연결속도를 만들어 냈고, 그로 인해 많은 사람이 소유할 수 없게 만들었다.

비트코인은 300GB 이상을 차지하는 블록체인이라는 DB가 있으며 비트코인의 모든 트랜잭션을 확인할 수 있고, 분 단위로 성장중이다.

비트코인이 수년간 겪은 문제는 바로 '블록체인 크기의 가속화된 성장'이다. 수십 메가바이트밖에 하지 않던 블록체인 레지스터리는 오늘날 수백 기가바이트로 늘어났다. 또한 앞으로도 비트코인을 사용하는 사람들이 많아질수록 이 성장은 더욱 빠르고, 커질 것이다.

이러한 bitcoin core 팀은 Block file pruning 이라고 불리는 것을 bitcoin core 0.11.0 version 에 추가하였다.(비트코인 블록체인의 '참조할 가능성이 없는 불필요한 정보'를 삭제한다면 비트코인의 용량은 10GB 미만의 수준으로 파악하고 있다.)

Block File Pruning 을 통해 비트코인의 용량을 최적화할 수 있다.

- Block pruning 을 통해 작은 버전의 '풀 블록체인'을 실행할 수 있다.
- 최신 블록체인을 다운로드하는 동안 필요하지 않은 오래된 데이터를 삭제할 수 있다.
- Prune mode에서 지갑을 실행하게 되면 이전 트랜잭션과 오래된 체인 기록이 삭제되어 디스크 공간을 절약할 수 있다.

블록체인은 모든 것을 살펴볼 수 있지만 크기가 크기 때문에 전부 저장하는 건 비효율적이다.

비트코인이 블록을 실행하고 검증하는 데 중요한 것은 블록 내 트랜잭션 내의 인/아웃풋의 사용 가능 여부이다. 그렇기에 굳이 모든 트랜잭션을 저장하고 있지 않아도 된다. 그러나 블록이 교체될 경우, 빠진 블록의 트랜잭션을 복구하는 과정이 필요하기 때문에 비교적 최신 정보만 가지고 있으면 된다.

풀 블록체인을 다운로드하여, 다운로드가 올바른지 확인한 후에 필요한 '최신 정보'만 복사한 뒤 나머지는 버린다. 저장한 블록체인은 풀 블록체인의 자식 트리(머클트리)이며, 원본 블록체인의 부분 복사본이다.

### 이더리움 프루닝
<center>
<img src="../../images/2022-09-06-blockchain_18th/image-20220906155507450.png" alt="image-20220906155507450" style="zoom: 33%;" />
</center>
이더리움에서는 프루닝을 State Trie Pruning이라고 한다.

State Trie Pruning은 현재 상태를 Prefix Tree의 일종인 Modified Merkle Patricia Trie(MPT, 상태전이 일반 머클 확장 페트리샤 트리)로 저장한다.  
이더리움에서 상태란 Account의 상태(Account state)이다. 그리고, 이 상태들이 모여 Global State를 이루고, 이는 Key-Value의 데이터 구조로 저장하고 있다.

Key : value = 32 byte Address : Account state

사용자가 늘어나면서 이더리운의 어카운트와 수정사항이 늘어나자 이는 계산이 버거워지고 느려지는 것으로 이어졌다. 이를 위해 머클 트리를 도입하여 기존의 값을 변경하는 것은 어느 정도 해소하였지만, 새로운 node를 추가하거나 삭제하는 것은 아직도 머클 트리의 정렬을 다시 계산해야 하는 복잡한 작업이다. 이에, 이더리움에서는 몇 가지의 기능을 추가하며 머클트리를 보완했고, 그 머클 트리가 바로 Modified Merkle Patricia Trie(MPT, 상태전이 일반 머클 확장 페트리샤 트리)이다. MPT는 State Root의 Hash를 계산하기 위해 전체를 볼 필요가 없다. 수정된 브랜치의 Hash만 다시 계산한다. 그렇기에 빠르게 root Hash를 찾을 수 있다.

MPT는 새로 삽입되는 노드의 수를 최소화한다. 예를 들어 위의 그림에서 오른쪽 자식의 값이 10에서 20으로 변경된 것뿐이다. 이 경우 10에서 20으로 변경된 노드의 부모 외의 다른 노드는 전부 기존의 노드를 재활용할 수 있다. 따라서 푸른색으로 그려진 3개의 노드만 새로 추가하면 된다.

위의 예제에서 붉은색으로 표시된 3개의 노드는 필요가 없다 하지만 이더리움은 블록의 Finality를 보자하지 않는다. 그래서 언제든지 N+1이 N으로 Retract 될 수 있다. 게다가 Web3 API를 통하여 과거의 State에 접근하는 것도 가능하기 때문에 현재 상태에서 안 쓰이는 노드를 바로 지울 수는 없습니다.

그렇다고 영원히 남겨둘 수도 없기 때문에 현재 이더리움에서 최신 State의 크기는 약 25GB 정도지만, 과거 State를 전부 저장하면 300GB를 넘어간다. 게다가 이 크기는 점점 커질 것이기 때문에 이를 전부 저장하는 것은 현실적이지 못하기 때문에 이더리움은 접근할 수 있는 과거 State를 127개로 제한하여 그보다 오래된 State에만 포함된 노드는 지워도 되도록 했다. 하지만 지워도 된다는 것과 지울 수 있는 것은 별개의 문제이다. DB에 저장되어 있는 노드 중 최근 127개의 노드에서 접근할 수 없는 노드를 찾아 지우는 것은 쉬운 문제가 아니다.

#### 이더리움 프루닝의 문제

이 문제는 컴퓨터 과학에서 오랫동안 풀어 온 Automatic Memory Management 문제와 비슷하다. 실제로 비틸락 부테린이 쓴 State Tree Pruning은 Reference Counting을 언급하고 있다. 하지만 이더리움의 State Trie Pruning은 일반적인 Memory Management와 다른 점이 하나 있다.

일반적인 Automatic Memory Management는 Volatile(휘발성이 있는)한 자원을 다룬다. 따라서 프로그램이 비정상 종류되는 상황을 고려하지 않아도 됩니다. 프로그램이 종료되면 관리해야 할 자원이 남아 있지 않기 때문이다. 하지만 State Trie의 노드는 DB에 저장되는 Persistence 메모리이기 때문에 프로그램의 비정상 종료로 인해 State Trie가 비정상적인 상태가 되면 복구할 방법이 없다. 비탈릭 부테린이 제시한 State Tree Pruning이 메인 넷에 들어가지 못한 것도 이러한 이유이다.

Reference Counting이 아닌 다른 방법으로 State Trie Pruning을 구현할 수도 있다. 예를 들어 Trace를 이용하는방법도 Tracing Garbage Collection도 Automatic Memory Management에서 흔히 사용되는 기법이다. 하지만 Trace에 필요한 추가적인 메모리나, Stop-the-world에 의해 생기는 성능 문제 등이 먼저 해결돼야 한다.

이러한 문제들로 현재 Go-Ethereum에서는 매우 한정적으로 State Trie Pruning을 한다. State Trie에 대해 캐시를 사용한데 이 캐시에만 저장된 노드에 대해서는 Pruning을 하고 DB에 저장된 노드는 Pruning을 하지 않는 방식이다. 캐싱된 노드는 서버가 정상적으로 종료되거나, 생성된지 128Block이 지났거나, 캐시 크기를 넘겼거나, 마지막으로 캐시된 노드가 DB에 저장된지 5분이 지나면 DB에 저장한다. 즉, 위의 조건을 만족하기 전에 Cache에서 삭제된 노드는 DB에 저장하지 않는다.

하지만 생성된 지 5분이 지나지 않아서 삭제되는 노드는 그리 많지 않다. 따라서 대부분의 삭제되었어야 할 노드는 여전히 DB에 남아있다. 이에 대해 이더리움에서는 State Pruning을 구현하는 것을 계속 시도하고 있다. 하지만 State Trie Pruning이 실제로 구현되기 전에는 Fast Sync를 사용하여 다음과 같은 방법을 사용하기를 권장한다.

다음 세 과정을 거치면, 새 노드에서는 Fast Sync로 동기화된 상태까지의 Garbage Node 없이 유효한 노드만 관리할 수 있다.

1. 새 클라이언트를 띄운다
2. 기존 클라이언트에서 새 클라이언트로 Fast Sync를 받는다.
3. 기존 클라이언트를 지운다.

위험 부담이 있는 Garbage Collection을 구현하는 것보다 안전하고 현실적인 해결적인 해결책이다. 이더리움에 Garbage Collection이 구현되기 전까지는 계속 위와 같은 방식을 이용해야 한다.

